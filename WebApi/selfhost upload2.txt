https://www.cnblogs.com/kest/p/8884389.html

一、WebApi上使用MultipartFormDataStreamProvider来接收文件时，会自动将文件保存至指定目录下，文件名什么的都是自动生成的。代码如下
[HttpPost, Route("savefiles")]
public async Task<bool> SaveFile(string projectId, string eventId)
{
	if (!Request.Content.IsMimeMultipartContent())
	{
		throw new HttpResponseException(HttpStatusCode.UnsupportedMediaType);
	} 
	string root = Path.Combine(HostingEnvironment.MapPath(ConfigurationManager.AppSettings["FileStorePath"]), DateTime.Now.ToShortDateString(), projectId);

	if (!Directory.Exists(root)) Directory.CreateDirectory(root);
	var provider = new MultipartFormDataStreamProvider(root);

	try
	{
		await Request.Content.ReadAsMultipartAsync(provider);
		
	}
	catch (Exception ex)
	{
		WebConfig.LoggerInstance.Error("上传文件出现异常：" + ex.Message);
	}
	return true;
}

===========================================================================================
二、自己保存文件
/// <summary>
/// 与MultipartFormDataStreamProvider对应，但不将文件直接存入指定位置，而是需要自己指定数据流如何保存 
/// </summary>
public class MultipartFormDataMemoryStreamProvider : MultipartStreamProvider
{
	private NameValueCollection _formData = new NameValueCollection();
	private Collection<bool> _isFormData = new Collection<bool>();

	/// <summary>  
	/// 获取文件对应的HttpContent集合,文件如何读取由实际使用方确定，可以ReadAsByteArrayAsync，也可以ReadAsStreamAsync  
	/// </summary>  
	public Collection<HttpContent> FileContents
	{
		get {
			if (this._isFormData.Count != this.Contents.Count)//两者总数不一致，认为未执行过必须的Request.Content.ReadAsMultipartAsync(provider)方法  
			{
				throw new InvalidOperationException("System.Net.Http.HttpContentMultipartExtensions.ReadAsMultipartAsync must be called first!");
			}
			return new Collection<HttpContent>(this.Contents.Where((ct, idx) => !this._isFormData[idx]).ToList());
		}
	}

	public NameValueCollection FormData
	{
		get {
			return this._formData;
		}
	}
	public override async Task ExecutePostProcessingAsync()
	{
		for (var i = 0; i < this.Contents.Count; i++)
		{
			if (!this._isFormData[i])//非文件  
			{
				continue;
			}
			var formContent = this.Contents[i];
			ContentDispositionHeaderValue contentDisposition = formContent.Headers.ContentDisposition;
			string formFieldName = UnquoteToken(contentDisposition.Name) ?? string.Empty;
			string formFieldValue = await formContent.ReadAsStringAsync();
			this.FormData.Add(formFieldName, formFieldValue);
		}
	}

	public override Stream GetStream(HttpContent parent, HttpContentHeaders headers)
	{
		if (parent == null)
		{
			throw new ArgumentNullException("parent");
		}
		if (headers == null)
		{
			throw new ArgumentNullException("headers");
		}
		ContentDispositionHeaderValue contentDisposition = headers.ContentDisposition;
		if (contentDisposition == null)
		{
			throw new InvalidOperationException("Content-Disposition is null");
		}
		this._isFormData.Add(string.IsNullOrEmpty(contentDisposition.FileName));
		return new MemoryStream();
	}

	/// <summary>  
	/// 复制自 System.Net.Http.FormattingUtilities 下同名方法，因为该类为internal，不能在其它命名空间下被调用  
	/// </summary>  
	/// <param name="token"></param>  
	/// <returns></returns>  
	private static string UnquoteToken(string token)
	{
		if (string.IsNullOrWhiteSpace(token))
		{
			return token;
		}
		if (token.StartsWith("\"", StringComparison.Ordinal) && token.EndsWith("\"", StringComparison.Ordinal) && token.Length > 1)
		{
			return token.Substring(1, token.Length - 2);
		}
		return token;
	}
}



---------------------------
使用方法
var provider = new MultipartFormDataMemoryStreamProvider();
try
{
	await Request.Content.ReadAsMultipartAsync(provider);
	foreach (var item in provider.Contents)
	{
		var ms = item.ReadAsStreamAsync().Result;
		using (var br = new BinaryReader(ms))
		{
			var data = br.ReadBytes((int)ms.Length);
			File.WriteAllBytes(root + "/"+eventId+".txt", data);
		}
	}
}
catch (Exception ex)
{
	WebConfig.LoggerInstance.Error("上传文件出现异常：" + ex.Message);
}