https://www.cnblogs.com/stg609/p/4052015.html

情景一：此茅坑有主了

 　　当一个资源同时被多个线程访问时，有可能会造成资源冲突（尤其是在存在多个写线程的时候）的情景。遇到这种情况，在 C# 中，
 我们可以使用 Interlocked、lock、Moniter、SpinLock、ReadWriteLockSlim、Mutex 来处理问题。

关于不同方案间的区别，请猛击这里。

 

　　什么情况下会被认为是情景一？

　　当你设计的类中出现静态变量、IO操作时，就会遇到情景一。因为这些资源是由多个对象共享的，不同的线程很同时去访问这些资源时，就可能会出现争用。

　　当一个类被设计成单例，且包含实例变量时，也会遇到情景一。因为实例变量属于这个单例，当多个线程操纵此单例时，该变量可能会被争用。

　　当一个类中的方法调用线程操作某个实例变量时，也会遇到情景一。

 

情景二：数量有限，先到先得

 　　情景一强调的是一对多的情形，而在情景二中，资源的数量并不唯一。相比于情景一，情景二侧重的是数量上的限制。
     而用于实现这一需求的类有：Semaphore、SemaphoreSlim。

　　 关于不同方案间的区别，请猛击这里。

 

　　什么情况下会被认为是情景二？

　　当所操作的公共资源存在并发数限制的时候（如数据库连接、IIS连接数限制等），就被认为是情景二。

 

情景三：我让你动，你才能动！

 　　情景三关注的是线程执行过程中的先后顺序，
     而用于保证这种先后顺序的方式就是通过线程通信的方式：ManualResetEventSlim、ManualResetEvent、AutoResetEvent。

　　 关于不同方案间的区别，请猛击这里。

 
　　什么情况下会被认为是情景三？

　　当两个线程所处理的事情有先后的依赖时，比如线程二的执行过程依赖线程一的执行结果，那就认为是情景三。